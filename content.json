{"pages":[{"title":"关于我","text":"开始结束","link":"/about/index.html"},{"title":"springboot","text":"","link":"/springboot/index.html"}],"posts":[{"title":"一款在线免费图床推荐","text":"现在很多人有了自己的博客/论坛，在写作过程中难免会插入一些配图，通常会因为图床问题焦躁，要么图片加载速度慢、要么连接过期了，总之就是各种问题频发，那么今天就介绍一款免费图床 Potato ，这款图床无需注册、不限容量、永久存储。 “ Potato ”是根据新浪图床API接口开发的免费图床程序，拥有网站和安卓APP两个形态。 每张图片文件最大2MB,支持每次最多同时上传10个文件集成了阿里图床、Upload_Cc、小米、Catbox、掘金论坛等多节点上传无需注册、永久免费、不限容量、永久存储 预览主界面预览 可以直接粘贴或拖拽图片至上传区，或点击右下角进行选择本地图片上传 上传成功上传成功后，可根据自己需求选择图片插入方式进行代码/链接复制进行使用","link":"/2020/04/06/%E4%B8%80%E6%AC%BE%E5%9C%A8%E7%BA%BF%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E6%8E%A8%E8%8D%90/"},{"title":"创建SpringBoot项目的三种姿势，你掌握几个？","text":"在传统的SSM项目中，我们前期工作总是大量操作XML配置文件，而且有时候项目出现问题，经常找不到原因出在哪里，可能是代码逻辑问题、或者是XML配置不正确，给我们开发人员带来不少困扰，SpringBoot的出现极大的减少了开发人员的大量工作，如： Create stand-alone Spring applications创建一个独立启动的Spring应用 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)内嵌Tomcat，Jetty或Undertow（无需部署WAR文件） Provide opinionated ‘starter’ dependencies to simplify your build configuration使用官方提供‘starter’依赖可以减少你项目构建所需配置 Automatically configure Spring and 3rd party libraries whenever possible尽可能自动配置Spring和第三方库 Provide production-ready features such as metrics, health checks, and externalized configuration提供可用于生产的功能，例如指标，运行状况检查和外部化配置 Absolutely no code generation and no requirement for XML configuration完全没有代码生成，也不需要XML配置 以上就是对于SpringBoot的简单了解，好不好用，用了才知道。接下来介绍创建SpringBoot项目的三种方式 1. 使用官方提供的构建方式1.1 点击进入到官方的Spring Initializr,如下界面1.2 填写所需信息后，点击GENERATE, 此时就会下载一个压缩文件到本地，我们将该文件解压缩，然后用IDE打开即可1.3 解压缩完成后，打开IDE工具，这里使用的是IntelliJ IDEA,点击Open,选择解压后文件打开，如下：1.4打开成功后，我们的第一个SpringBoot项目就创建完成了。 2. 使用IDE(IntelliJ IDEA)构建2.1 我们打开IntelliJ IDEA,点击Create New Project2.2 选择Spring Initializr,选择SDK,构建方式使用官方提供方式，选择完成后点击Next2.3 填写方式同官方方式,填写完成后，点击Next：2.4 选择所需依赖，然后Next，最后Finish,项目就创建成功了 3. 通过改造一个Maven项目3.1 我们打开IntelliJ IDEA,点击Create New Project，选择Maven，然后点击Next3.2 填写GroupId等信息，点击Next，最后Finish3.3 上面步骤结束后，Maven项目创建成功，接下来我们进行改造打开pom.xml文件，添加如下配置到&amp;lt;project&amp;gt;&amp;lt;/project&amp;gt;节点下 12345678910111213141516171819&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 添加完成后我们还需添加一个启动类，如下： 123456@SpringBootApplicationpublic class Springboot3Application { public static void main(String[] args) { SpringApplication.run(Springboot3Application.class,args); }} 至此，Maven方式就创建完成了。","link":"/2020/04/07/SpringBoot/%E5%88%9B%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF%EF%BC%8C%E4%BD%A0%E9%83%BD%E7%9F%A5%E9%81%93%E5%90%97/"},{"title":"SpringBoot中整合fastjson，自定义jackson、gson","text":"如今炒的火热的前后端分离项目，大多数开发人员选择RESTful设计风格，Java Web 人员经常要设计 RESTful API，这种设计通常使用 json 数据进行交互。那么前端传入的 json 数据如何序列化成 Java 对象，后端返回的结果又如何将 Java 对象解析成 json 格式数据返回给前端，在整个解析过程，HttpMessageConverter 起到了重要作用，各大公司实现了自己的HttpMessageConverter ，如： jackson的MappingJackson2HttpMessageConverter; gson的GsonHttpMessageConverter; fastjson的FastJsonHttpMessageConverter等等。 1. 自定义jacksonspring-boot-stater-web依赖的json解析是jackson,同时也为我们进行了jackson的一系列自动化配置，这样我们不需要导入其他json依赖，就可以直接使用，其中起到关键作用的是MappingJackson2HttpMessageConverter;123456789@Bean//如果我们自己提供MappingJackson2HttpMessageConverter则不使用Springboot提供的@ConditionalOnMissingBean(value = MappingJackson2HttpMessageConverter.class, ignoredType = { \"org.springframework.hateoas.server.mvc.TypeConstrainedMappingJackson2HttpMessageConverter\", \"org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter\" })MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) { return new MappingJackson2HttpMessageConverter(objectMapper);} @ConditionalOnMissingBean(value = MappingJackson2HttpMessageConverter.class,..)注解也告诉我们，如果没有找到自定义的MappingJackson2HttpMessageConverter，将使用下面springboot提供的。如果我们要自定义jackson只需重新定义MappingJackson2HttpMessageConverter，那么springboot提供的将不会生效，自定义方式如下：1234567891011121314@Configurationpublic class WebMvcConfig { @Bean MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(){ MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); //自定义json日期格式 objectMapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")); //其他自定义配置 converter.setObjectMapper(objectMapper); return converter; }} 2. 自定义Gson由于spring-boot-stater-web已引入jackson，如果要使用gson需将jackson包排除掉，然后引入gson依赖即可，在pom.xml中添加如下配置：12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 移除默认的spring-boot-starter-json依赖 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入gson依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 此时我们发现gson依赖并不需要填写版本号，那是因为，springboot也为gson做了一套默认配置，同时管理gson版本，具体可查看spring-boot-dependencies下的pom依赖；同样我们如果要自定义gson配置，只需重新定义GsonHttpMessageConverter即可：1234567891011@BeanGsonHttpMessageConverter gsonHttpMessageConverter(){ GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); GsonBuilder gsonBuilder = new GsonBuilder(); //使用GsonBuilder配置日期格式 gsonBuilder.setDateFormat(\"yyyy-MM-dd\"); //其他配置 converter.setGson(gsonBuilder.create()); return converter;} 3. 整合fastjson同样将jackson包排除掉，然后引入fastjson依赖1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 移除默认的spring-boot-starter-json依赖 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入fastjson依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt; fastjson与jackson和gson略有不同，springboot没有提供fastjson的自动化配置，所以，就需要我们手动提供fastjson配置，如下：12345678910@BeanFastJsonHttpMessageConverter fastJsonHttpMessageConverter(){ FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig config = new FastJsonConfig(); //配置日期格式 config.setDateFormat(\"yyyy-MM-dd\"); //其他配置 converter.setFastJsonConfig(config); return converter;}","link":"/2020/04/09/SpringBoot/SpringBoot%E4%B8%AD%E6%95%B4%E5%90%88fastjson%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89jackson%E3%80%81gson/"},{"title":"对比Spring和Spring Boot中properties文件不同处理方式","text":"项目中我们总避免不了使用properties文件定义一些配置属性，然后将这些配置注入到对应属性上让其生效，那么Spring中和Spring Boot对properties处理有什么差别呢？那就一起来看看。 注意：本文创建一个简单的SpringBoot项目，分别使用两种方式来演示 1. Spring中properties属性注入1.1 配置属性值到application.properties中1.1.1 创建实体类User.java123456public class User { private Integer id; private String name; private String address; //省略getter和setter方法} 1.1.2 将属性值配置在application.properties1234# application.properties配置文件会在项目启动时就加载到Spring容器user.id=1user.name=wanikuser.address=beijing 1.1.3 注入属性到User12345678910111213@Component //将该bean添加到Spring容器中public class User { //application.properties配置文件会在项目启动时就加载到Spring容器 //这里我们可以直接使用@Value(\"${key}\")注解将properties中的值注入到指定属性 @Value(\"${user.id}\") private Integer id; @Value(\"${user.name}\") private String name; @Value(\"${user.address}\") private String address; //省略getter/setter方法，必须存在setter方法} 1.1.4 测试123456789101112//SpringBoot测试类@SpringBootTestclass PropertiesApplicationTests { //注入User对象到测试类 @Autowired User user; @Test void test1(){ System.out.println(user); }} 打印结果： 1.2 定义外部配置文件user.properties在外部自定义properties文件也是我们常用的一种方式，比如db.properties等，那么这个文件在项目启动时不会被自动加载到Spring容器中，那么我们就要通过修改上述要注入的User实现。 通过@PropertySource(path)注解指定properties文件路径 1234567891011121314@Component //将该bean添加到Spring容器中@PropertySource(\"classpath:user.properties\") //指定properties文件路径public class User { //application.properties配置文件会在项目启动时就加载到Spring容器 //这里我们可以直接使用@Value(\"${key}\")注解将properties中的值注入到指定属性 @Value(\"${user.id}\") private Integer id; @Value(\"${user.name}\") private String name; @Value(\"${user.address}\") private String address; //省略getter、setter方法} 测试：第二种方式测试成功上述介绍两种在Spring中注入properties方式，这两种方式同样在SpringBoot中适用，下面介绍Spring Boot中提供的另一种方式 2. Spring Boot中properties属性注入Spring Boot提供了一种属性安全的注入方式,在属性值较多时这种方式非常简便，省略掉在每个属性上一对一通过@Value进行注入：同样修改上述User类，如下： 123456789101112@Component //将该bean添加到Spring容器中@PropertySource(\"classpath:user.properties\")@ConfigurationProperties(prefix = \"user\")public class User { //@Value(\"${user.id}\") private Integer id; //@Value(\"${user.name}\") private String name; //@Value(\"${user.address}\") private String address; //省略getter/setter方法} 注意：这种方式只适用于properties文件注入，yaml或yml类型不适用。","link":"/2020/04/08/SpringBoot/%E5%AF%B9%E6%AF%94Spring%E5%92%8CSpring%20Boot%E4%B8%ADproperties%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"}],"tags":[{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","link":"/tags/IntelliJ-IDEA/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"properties","slug":"properties","link":"/tags/properties/"}],"categories":[{"name":"推荐工具","slug":"推荐工具","link":"/categories/%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"}]}